from langchain_text_splitters import CharacterTextSplitter, RecursiveCharacterTextSplitter

# 1. Sample Text (A generic technical explanation)
cleaned_text = """
Retrieval-Augmented Generation (RAG) is an architectural framework that improves the quality and relevance of responses generated by Large Language Models (LLMs).
Instead of relying solely on the pre-trained knowledge of the model, RAG retrieves relevant information from an external knowledge base and feeds it to the model.

The process involves three main steps:
1. Retrieval: The system searches for documents relevant to the user's query.
2. Augmentation: The retrieved documents are combined with the original query to form a prompt.
3. Generation: The LLM generates a response based on the augmented prompt.

Chunking is a critical part of the ingestion pipeline. If chunks are too small, they may lack context.
If chunks are too large, they may contain irrelevant information or exceed the model's context window.
Finding the right balance is key to building an effective RAG system.
"""

def print_chunks(chunks, title):
    print(f"\n--- {title} ---")
    print(f"Total Chunks: {len(chunks)}")
    for i, chunk in enumerate(chunks):
        print(f"Chunk {i+1} (Size: {len(chunk)}): {repr(chunk)}")
        print("-" * 20)

# 2. Fixed Size Chunking (Character Splitter)
# Splits strictly by character count. Can break words or sentences.
print("=== STRATEGY 1: Fixed Size Chunking ===")
fixed_splitter = CharacterTextSplitter(
    separator="",           # Split on every character if needed (strict size)
    chunk_size=100,         # Size of each chunk
    chunk_overlap=20,       # Overlap to maintain some continuity
    is_separator_regex=False
)
fixed_chunks = fixed_splitter.split_text(cleaned_text)
print_chunks(fixed_chunks, "Fixed Size (100 chars, 20 overlap)")


# 3. Recursive Character Chunking (Recommended)
# Tries to split on paragraphs first, then newlines, then spaces, then chars.
# Keeps semantically related text together.
print("\n=== STRATEGY 2: Recursive Character Chunking ===")
recursive_splitter = RecursiveCharacterTextSplitter(
    chunk_size=100,
    chunk_overlap=20,
    separators=["\n\n", "\n", " ", ""] # Priority order for splitting
)
recursive_chunks = recursive_splitter.split_text(cleaned_text)
print_chunks(recursive_chunks, "Recursive (100 chars, 20 overlap)")

# 4. Comparing the results
# Notice how the Recursive splitter tries to avoid breaking sentences mid-way if possible,
# whereas the Fixed splitter just cuts off at the character limit.
